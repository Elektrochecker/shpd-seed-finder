From c9c39911f75b3046f693aa44b8d990bd02fc0add Mon Sep 17 00:00:00 2001
From: Timon Lilje <timon.lilje@gmail.com>
Date: Wed, 24 Jan 2024 16:09:22 +0100
Subject: [PATCH] seedfinder

---
 .gitignore                                    |   3 +
 .../java/com/watabou/utils/DeviceCompat.java  |   2 +-
 build.gradle                                  |   4 +-
 .../shatteredpixeldungeon/SPDSettings.java    |   2 +-
 .../shatteredpixeldungeon/SeedFinder.java     | 808 ++++++++++++++++++
 .../ShatteredPixelDungeon.java                |  11 +-
 .../actors/mobs/ArmoredStatue.java            |   2 +-
 .../actors/mobs/Statue.java                   |   2 +-
 .../actors/mobs/npcs/Wandmaker.java           |   2 +-
 .../shatteredpixeldungeon/items/Heap.java     |  14 +-
 .../shatteredpixeldungeon/items/Item.java     |   4 +
 .../items/potions/Potion.java                 |   5 +
 .../items/rings/Ring.java                     |   5 +
 .../items/scrolls/Scroll.java                 |   5 +
 .../shatteredpixeldungeon/levels/Level.java   |   2 +
 .../levels/RegularLevel.java                  |   3 +
 .../levels/rooms/special/SacrificeRoom.java   |   1 +
 .../levels/rooms/standard/EntranceRoom.java   |  32 -
 .../messages/Languages.java                   |   4 -
 .../desktop/DesktopLauncher.java              |   4 +
 20 files changed, 861 insertions(+), 54 deletions(-)
 create mode 100644 core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/SeedFinder.java

diff --git a/.gitignore b/.gitignore
index 5b124b5b1..dced0190d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -18,3 +18,6 @@ local.properties
 #intellij project files
 *.iml
 *.idea
+
+#git patch files
+*.patch
\ No newline at end of file
diff --git a/SPD-classes/src/main/java/com/watabou/utils/DeviceCompat.java b/SPD-classes/src/main/java/com/watabou/utils/DeviceCompat.java
index 48e1e7f16..f0d21bb2b 100644
--- a/SPD-classes/src/main/java/com/watabou/utils/DeviceCompat.java
+++ b/SPD-classes/src/main/java/com/watabou/utils/DeviceCompat.java
@@ -60,7 +60,7 @@ public class DeviceCompat {
 	}
 	
 	public static boolean isDebug(){
-		return Game.version.contains("INDEV");
+		return true;
 	}
 	
 	public static void log( String tag, String message ){
diff --git a/build.gradle b/build.gradle
index 8855fb2ae..8b8301d75 100644
--- a/build.gradle
+++ b/build.gradle
@@ -12,8 +12,8 @@ buildscript {
 allprojects {
 
     ext {
-        appName = 'Shattered Pixel Dungeon'
-        appPackageName = 'com.shatteredpixel.shatteredpixeldungeon'
+        appName = 'Shattered Pixel Dungeon Seedfinder'
+        appPackageName = 'com.elektrochecker.seedfinder'
 
         appVersionCode = 765
         appVersionName = '2.3.0'
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/SPDSettings.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/SPDSettings.java
index c8e58a03a..2bd014bd0 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/SPDSettings.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/SPDSettings.java
@@ -217,7 +217,7 @@ public class SPDSettings extends GameSettings {
 	}
 	
 	public static boolean intro() {
-		return getBoolean( KEY_INTRO, true );
+		return false;
 	}
 	
 	public static void lastClass( int value ) {
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/SeedFinder.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/SeedFinder.java
new file mode 100644
index 000000000..6c493d9f6
--- /dev/null
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/SeedFinder.java
@@ -0,0 +1,808 @@
+package com.shatteredpixel.shatteredpixeldungeon;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.PrintWriter;
+import java.io.Writer;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Properties;
+import java.util.Scanner;
+import java.util.TimeZone;
+
+import com.shatteredpixel.shatteredpixeldungeon.actors.hero.HeroClass;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.ArmoredStatue;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.CrystalMimic;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.GoldenMimic;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mimic;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mob;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.npcs.Ghost;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.npcs.Imp;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.npcs.Wandmaker;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Statue;
+import com.shatteredpixel.shatteredpixeldungeon.items.armor.Armor;
+import com.shatteredpixel.shatteredpixeldungeon.items.artifacts.Artifact;
+import com.shatteredpixel.shatteredpixeldungeon.items.Dewdrop;
+import com.shatteredpixel.shatteredpixeldungeon.items.EnergyCrystal;
+import com.shatteredpixel.shatteredpixeldungeon.items.Gold;
+import com.shatteredpixel.shatteredpixeldungeon.items.Heap;
+import com.shatteredpixel.shatteredpixeldungeon.items.Heap.Type;
+import com.shatteredpixel.shatteredpixeldungeon.items.Item;
+import com.shatteredpixel.shatteredpixeldungeon.items.journal.Guidebook;
+import com.shatteredpixel.shatteredpixeldungeon.items.keys.CrystalKey;
+import com.shatteredpixel.shatteredpixeldungeon.items.keys.GoldenKey;
+import com.shatteredpixel.shatteredpixeldungeon.items.keys.IronKey;
+import com.shatteredpixel.shatteredpixeldungeon.items.potions.Potion;
+import com.shatteredpixel.shatteredpixeldungeon.items.quest.CeremonialCandle;
+import com.shatteredpixel.shatteredpixeldungeon.items.quest.CorpseDust;
+import com.shatteredpixel.shatteredpixeldungeon.items.quest.Embers;
+import com.shatteredpixel.shatteredpixeldungeon.items.quest.Pickaxe;
+import com.shatteredpixel.shatteredpixeldungeon.items.rings.Ring;
+import com.shatteredpixel.shatteredpixeldungeon.items.scrolls.Scroll;
+import com.shatteredpixel.shatteredpixeldungeon.items.wands.Wand;
+import com.shatteredpixel.shatteredpixeldungeon.items.weapon.melee.MeleeWeapon;
+import com.shatteredpixel.shatteredpixeldungeon.items.weapon.Weapon;
+import com.shatteredpixel.shatteredpixeldungeon.levels.Level;
+import com.shatteredpixel.shatteredpixeldungeon.levels.RegularLevel;
+import com.shatteredpixel.shatteredpixeldungeon.utils.DungeonSeed;
+
+import com.watabou.utils.Random;
+import com.watabou.noosa.Game;
+
+public class SeedFinder {
+	enum Condition {
+		ANY, ALL
+	};
+
+	public static class Options {
+		public static int floors;
+		public static Condition condition;
+		public static String itemListFile;
+		public static String ouputFile;
+		public static long seed;
+
+		public static boolean searchForDaily;
+		public static int DailyOffset;
+
+		public static boolean ignoreBlacklist;
+		public static boolean useChallenges;
+		public static int challenges;
+
+		public static boolean useRooms;
+		public static boolean logPotions;
+		public static boolean logScrolls;
+		public static boolean logEquipment;
+		public static boolean logRings;
+		public static boolean logWands;
+		public static boolean logArtifacts;
+		public static boolean logOther;
+
+		public static boolean trueRandom;
+		public static boolean sequentialMode;
+		public static long startingSeed;
+		public static int infoSpacing;
+		public static String spacingChar;
+	}
+
+	public class HeapItem {
+		public Item item;
+		public Heap heap;
+
+		public HeapItem(Item item, Heap heap) {
+			this.item = item;
+			this.heap = heap;
+		}
+	}
+
+	List<Class<? extends Item>> blacklist;
+	ArrayList<String> itemList;
+
+	private void parseArgs(String[] args) {
+		if (args.length == 2) {
+			Options.ouputFile = "stdout";
+			Options.floors = Integer.parseInt(args[0]);
+			Options.seed = DungeonSeed.convertFromText(args[1]);
+
+			if (args[1].contains("daily")) {
+				Options.searchForDaily = true;
+				String offsetNumber = args[1].replace("daily", "");
+
+				if (!offsetNumber.equals("")) {
+					Options.DailyOffset = Integer.valueOf(offsetNumber);
+				}
+
+			}
+
+			return;
+		}
+
+		Options.floors = Integer.parseInt(args[0]);
+		Options.condition = args[1].equals("any") ? Condition.ANY : Condition.ALL;
+		Options.itemListFile = args[2];
+
+		if (args.length < 4)
+			Options.ouputFile = "out.txt";
+
+		else
+			Options.ouputFile = args[3];
+	}
+
+	private void parseConfig(String fileName) {
+		Properties cfg = new Properties();
+
+		try (FileInputStream stream = new FileInputStream(fileName)) {
+			cfg.load(stream);
+		} catch (FileNotFoundException ex) {
+			try (OutputStream output = new FileOutputStream(fileName)) {
+				Properties prop = new Properties();
+
+				// if no config is present, restore these values
+				prop.setProperty("useChallenges", "true");
+				prop.setProperty("ignoreBlacklist", "false");
+				prop.setProperty("trueRandomMode", "false");
+				prop.setProperty("sequentialMode", "false");
+				prop.setProperty("useRooms", "false");
+				prop.setProperty("logPotions", "true");
+				prop.setProperty("logScrolls", "true");
+				prop.setProperty("logEquipment", "true");
+				prop.setProperty("logRings", "true");
+				prop.setProperty("logWands", "true");
+				prop.setProperty("logArtifacts", "true");
+				prop.setProperty("logOther", "true");
+
+				prop.setProperty("startingSeed", "0");
+				prop.setProperty("infoSpacing", "33");
+				prop.setProperty("spacingChar", "33");
+
+				prop.setProperty("chal.hostileChampions", "false");
+				prop.setProperty("chal.badderBosses", "false");
+				prop.setProperty("chal.onDiet", "false");
+				prop.setProperty("chal.faithIsMyArmor", "false");
+				prop.setProperty("chal.pharmacophobia", "false");
+				prop.setProperty("chal.barrenLand", "false");
+				prop.setProperty("chal.swarmIntelligence", "false");
+				prop.setProperty("chal.intoDarkness", "false");
+				prop.setProperty("chal.forbiddenRunes", "false");
+
+				prop.store(output, null);
+
+				System.out.printf("\nERROR: no config file found. created " + fileName + "\n\n");
+			} catch (IOException io) {
+			}
+		} catch (IOException ex) {
+		}
+
+		// pull options from config
+		Options.useChallenges = cfg.getProperty("useChallenges").equals("true");
+		Options.useRooms = cfg.getProperty("useRooms").equals("true");
+		Options.logPotions = cfg.getProperty("logPotions").equals("true");
+		Options.logScrolls = cfg.getProperty("logScrolls").equals("true");
+		Options.logEquipment = cfg.getProperty("logEquipment").equals("true");
+		Options.logRings = cfg.getProperty("logRings").equals("true");
+		Options.logWands = cfg.getProperty("logWands").equals("true");
+		Options.logArtifacts = cfg.getProperty("logArtifacts").equals("true");
+		Options.logOther = cfg.getProperty("logOther").equals("true");
+		Options.ignoreBlacklist = cfg.getProperty("ignoreBlacklist").equals("true");
+		Options.trueRandom = cfg.getProperty("trueRandomMode").equals("true");
+		Options.sequentialMode = cfg.getProperty("sequentialMode").equals("true");
+		Options.startingSeed = DungeonSeed.convertFromText(cfg.getProperty("startingSeed"));
+		Options.infoSpacing = Integer.valueOf(cfg.getProperty("infoSpacing"));
+		Options.spacingChar = cfg.getProperty("spacingChar");
+		if (Options.spacingChar.length() != 1) Options.spacingChar = " ";
+
+		// build challenge code from config
+		Options.challenges = 0;
+		if (Options.useChallenges) {
+			Options.challenges += cfg.getProperty("chal.hostileChampions").equals("true") ? Challenges.CHAMPION_ENEMIES : 0;
+			Options.challenges += cfg.getProperty("chal.badderBosses").equals("true") ? Challenges.STRONGER_BOSSES : 0;
+			Options.challenges += cfg.getProperty("chal.onDiet").equals("true") ? Challenges.NO_FOOD : 0;
+			Options.challenges += cfg.getProperty("chal.faithIsMyArmor").equals("true") ? Challenges.NO_ARMOR : 0;
+			Options.challenges += cfg.getProperty("chal.pharmacophobia").equals("true") ? Challenges.NO_HEALING : 0;
+			Options.challenges += cfg.getProperty("chal.barrenLand").equals("true") ? Challenges.NO_HERBALISM : 0;
+			Options.challenges += cfg.getProperty("chal.swarmIntelligence").equals("true") ? Challenges.SWARM_INTELLIGENCE : 0;
+			Options.challenges += cfg.getProperty("chal.intoDarkness").equals("true") ? Challenges.DARKNESS : 0;
+			Options.challenges += cfg.getProperty("chal.forbiddenRunes").equals("true") ? Challenges.NO_SCROLLS : 0;
+		}
+	}
+
+	private ArrayList<String> getItemList() {
+		ArrayList<String> itemList = new ArrayList<>();
+
+		try {
+			Scanner scanner = new Scanner(new File(Options.itemListFile));
+
+			while (scanner.hasNextLine()) {
+				itemList.add(scanner.nextLine());
+			}
+
+			scanner.close();
+
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		}
+
+		return itemList;
+	}
+
+	private void addTextItems(String caption, ArrayList<HeapItem> items, StringBuilder builder, String padding) {
+		if (!items.isEmpty()) {
+			builder.append(caption + ":\n");
+
+			for (HeapItem item : items) {
+				Item i = item.item;
+				Heap h = item.heap;
+
+				String cursed = "";
+
+				if (((i instanceof Armor && ((Armor) i).hasGoodGlyph())
+						|| (i instanceof Weapon && ((Weapon) i).hasGoodEnchant()) || (i instanceof Wand)
+						|| (i instanceof Artifact)) && i.cursed) {
+
+					cursed = "cursed ";
+				}
+
+				if (i instanceof Scroll || i instanceof Potion || i instanceof Ring) {
+					int txtLength = i.title().length();
+
+					if (i.cursed) {
+						builder.append("- cursed ");
+						txtLength += 7;
+					} else {
+						builder.append("- ");
+					}
+
+					// make anonymous names show in the same column to look nice
+					String tabstring = "";
+					for (int j = 0; j < Math.max(1, Options.infoSpacing - txtLength); j++) {
+						tabstring += Options.spacingChar;
+					}
+
+					builder.append(i.title().toLowerCase() + tabstring); // item
+					builder.append(i.anonymousName().toLowerCase().replace(" potion", "").replace("scroll of ", "")
+							.replace(" ring", "")); // color, rune or gem
+
+					// if both location and type are logged only space to the right once
+					if (h.type != Type.HEAP) {
+						builder.append(" (" + h.title().toLowerCase() + ")");
+					}
+				} else {
+					String name = cursed + i.title().toLowerCase();
+					builder.append("- " + name);
+
+					// also make item location log in the same column
+					if (h.type != Type.HEAP) {
+						String tabstring = "";
+						for (int j = 0; j < Math.max(1, Options.infoSpacing - name.length()); j++) {
+							tabstring += Options.spacingChar;
+						}
+
+						builder.append(tabstring + "(" + h.title().toLowerCase() + ")");
+					}
+				}
+				builder.append("\n");
+			}
+
+			builder.append(padding);
+		}
+	}
+
+	private void addTextQuest(String caption, ArrayList<Item> items, StringBuilder builder) {
+		if (!items.isEmpty()) {
+			builder.append(caption + ":\n");
+
+			for (Item i : items) {
+				if (i.cursed)
+					builder.append("- cursed " + i.title().toLowerCase() + "\n");
+
+				else
+					builder.append("- " + i.title().toLowerCase() + "\n");
+			}
+
+			builder.append("\n");
+		}
+	}
+
+	public SeedFinder(String[] args) {
+		System.out.print("Elektrocheckers seed finder for SHPD v" + Game.version + "\n");
+
+		parseConfig("seedfinder.cfg");
+		parseArgs(args);
+
+		if (args.length == 2) {
+			logSeedItems(Long.toString(Options.seed), Options.floors);
+
+			return;
+		}
+
+		itemList = getItemList();
+
+		try {
+			Writer outputFile = new FileWriter(Options.ouputFile);
+			outputFile.close();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+
+		// only generate natural seeds
+		if (Options.trueRandom) {
+			for (int i = 0; i < DungeonSeed.TOTAL_SEEDS; i++) {
+				long seed = DungeonSeed.randomSeed();
+				if (testSeed(Long.toString(seed), Options.floors)) {
+					System.out.printf("Found valid seed %s (%d)\n", DungeonSeed.convertToCode(Dungeon.seed),
+							Dungeon.seed);
+					logSeedItems(Long.toString(seed), Options.floors);
+				}
+			}
+
+		// sequential mode: start at 0
+		} else if (Options.sequentialMode) {
+			for (long i = Options.startingSeed; i < DungeonSeed.TOTAL_SEEDS; i++) {
+				if (testSeed(Long.toString(i), Options.floors)) {
+					System.out.printf("Found valid seed %s (%d)\n", DungeonSeed.convertToCode(Dungeon.seed),
+							Dungeon.seed);
+					logSeedItems(Long.toString(i), Options.floors);
+				}
+			}
+
+		// default (random) mode
+		} else {
+			for (long i = Random.Long(DungeonSeed.TOTAL_SEEDS); i < DungeonSeed.TOTAL_SEEDS; i++) {
+				if (testSeed(Long.toString(i), Options.floors)) {
+					System.out.printf("Found valid seed %s (%d)\n", DungeonSeed.convertToCode(Dungeon.seed), Dungeon.seed);
+					logSeedItems(Long.toString(i), Options.floors);
+				}
+			}
+		}
+	}
+
+	private ArrayList<String> getRooms() {
+		ArrayList<String> rooms = new ArrayList<String>();
+		for (int k = 0; k < RegularLevel.roomList.size(); k++) {
+			String room = RegularLevel.roomList.get(k).toString()
+					.replace("com.shatteredpixel.shatteredpixeldungeon.levels.rooms.", "");
+
+			String roomType = "standard";
+
+			// remove Java object instance code
+			room = room.replaceAll("@[a-z0-9]{4,}", "");
+
+			// turn camel case to normal text
+			room = room.replaceAll("([a-z])([A-Z])", "$1 $2").toLowerCase();
+
+			if (room.contains("special")) {
+				room = room.replace("special.", "");
+				roomType = "special";
+			} else if (room.contains("secret")) {
+				room = room.replace("secret.", "");
+				roomType = "secret";
+			} else if (room.contains("standard")) {
+				room = room.replace("standard.", "");
+				roomType = "standard";
+			}
+
+			String tabstring = "";
+			for (int j = 0; j < Math.max(1,
+					Options.infoSpacing - room.length()); j++) {
+				tabstring += Options.spacingChar;
+			}
+
+			room += tabstring + roomType;
+
+			rooms.add(room);
+		}
+
+		Collections.sort(rooms);
+		return rooms;
+	}
+
+	private ArrayList<Heap> getMobDrops(Level l) {
+		ArrayList<Heap> heaps = new ArrayList<>();
+
+		for (Mob m : l.mobs) {
+			if (m instanceof Statue) {
+				Heap h = new Heap();
+				h.items = new LinkedList<>();
+				h.items.add(((Statue) m).weapon.identify());
+				h.type = Type.STATUE;
+				heaps.add(h);
+			}
+
+			else if (m instanceof ArmoredStatue) {
+				Heap h = new Heap();
+				h.items = new LinkedList<>();
+				h.items.add(((ArmoredStatue) m).armor.identify());
+				h.items.add(((ArmoredStatue) m).weapon.identify());
+				h.type = Type.STATUE;
+				heaps.add(h);
+			}
+
+			else if (m instanceof Mimic) {
+				Heap h = new Heap();
+				h.items = new LinkedList<>();
+
+				for (Item item : ((Mimic) m).items)
+					h.items.add(item.identify());
+
+				if (m instanceof GoldenMimic)
+					h.type = Type.GOLDEN_MIMIC;
+				else if (m instanceof CrystalMimic)
+					h.type = Type.CRYSTAL_MIMIC;
+				else
+					h.type = Type.MIMIC;
+				heaps.add(h);
+			}
+		}
+
+		return heaps;
+	}
+
+	private boolean testSeed(String seed, int floors) {
+		SPDSettings.customSeed(seed);
+		SPDSettings.challenges(Options.challenges);
+		GamesInProgress.selectedClass = HeroClass.WARRIOR;
+		Dungeon.init();
+
+		boolean[] itemsFound = new boolean[itemList.size()];
+
+		for (int i = 0; i < floors; i++) {
+
+			Level l = Dungeon.newLevel();
+
+			// skip boss floors
+			//for some reason this fucks up quest item searching
+
+			// if (Dungeon.depth % 5 == 0) {
+			// 	continue;
+			// }
+
+			ArrayList<Heap> heaps = new ArrayList<>(l.heaps.valueList());
+			heaps.addAll(getMobDrops(l));
+
+			// check rooms
+			if (Options.useRooms) {
+				ArrayList<String> rooms = getRooms();
+				if (rooms.size() > 0) {
+					for (int k = 0; k < rooms.size(); k++) {
+						for (int j = 0; j < itemList.size(); j++) {
+							if (rooms.get(k).contains(itemList.get(j))) {
+								if (!itemsFound[j]) {
+									itemsFound[j] = true;
+									break;
+								}
+							}
+						}
+					}
+				}
+			}
+
+			// check heap items
+			for (Heap h : heaps) {
+				for (Item item : h.items) {
+					item.identify();
+
+					for (int j = 0; j < itemList.size(); j++) {
+						if (item.title().toLowerCase().contains(itemList.get(j))
+								|| item.anonymousName().toLowerCase().contains(itemList.get(j))) {
+							if (itemsFound[j] == false) {
+								itemsFound[j] = true;
+								break;
+							}
+						}
+					}
+				}
+			}
+
+			// check sacrificial fire
+			if (l.sacrificialFireItem != null) {
+				for (int j = 0; j < itemList.size(); j++) {
+					if (l.sacrificialFireItem.title().toLowerCase().contains(itemList.get(j))) {
+						if (!itemsFound[j]) {
+							itemsFound[j] = true;
+							break;
+						}
+					}
+				}
+			}
+
+			// check quests
+			Item[] questitems = {
+					Ghost.Quest.armor,
+					Ghost.Quest.weapon,
+					Wandmaker.Quest.wand1,
+					Wandmaker.Quest.wand2,
+					Imp.Quest.reward
+			};
+
+			if (Ghost.Quest.armor != null) {
+				questitems[0] = Ghost.Quest.armor.inscribe(Ghost.Quest.glyph);
+				questitems[1] = Ghost.Quest.weapon.enchant(Ghost.Quest.enchant);
+			}
+
+			for (int j = 0; j < itemList.size(); j++) {
+				for (int k = 0; k < 5; k++) {
+					if (questitems[k] != null) {
+						if (questitems[k].identify().title().toLowerCase().contains(itemList.get(j))) {
+							if (!itemsFound[j]) {
+								itemsFound[j] = true;
+								break;
+							}
+						}
+					}
+				}
+			}
+
+			Dungeon.depth++;
+		}
+
+		if (Options.condition == Condition.ANY) {
+			for (int i = 0; i < itemList.size(); i++) {
+				if (itemsFound[i] == true)
+					return true;
+			}
+
+			return false;
+		}
+
+		else {
+			for (int i = 0; i < itemList.size(); i++) {
+				if (itemsFound[i] == false)
+					return false;
+			}
+
+			return true;
+		}
+	}
+
+	private void logSeedItems(String seed, int floors) {
+		PrintWriter out = null;
+		OutputStream out_fd = System.out;
+
+		try {
+			if (Options.ouputFile != "stdout")
+				out_fd = new FileOutputStream(Options.ouputFile, true);
+
+			out = new PrintWriter(out_fd);
+		} catch (FileNotFoundException e) { // gotta love Java mandatory exceptions
+			e.printStackTrace();
+		}
+
+		String seedinfotext = "";
+
+		if (Options.searchForDaily) {
+			Dungeon.daily = true;
+			long DAY = 1000 * 60 * 60 * 24;
+			long currentDay = (long) Math.floor(Game.realTime / DAY) + Options.DailyOffset;
+			SPDSettings.lastDaily(DAY * currentDay);
+			SPDSettings.challenges(Options.challenges);
+			DateFormat format = new SimpleDateFormat("yyyy-MM-dd", Locale.ROOT);
+			format.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+			GamesInProgress.selectedClass = HeroClass.WARRIOR;
+			Dungeon.init();
+			seedinfotext += format.format(new Date(SPDSettings.lastDaily()));
+
+			out.printf("Items for daily run %s (%d):\n\n", seedinfotext, Dungeon.seed);
+		} else {
+			Dungeon.daily = false;
+			SPDSettings.customSeed(seed);
+			SPDSettings.challenges(Options.challenges);
+			GamesInProgress.selectedClass = HeroClass.WARRIOR;
+			Dungeon.init();
+			seedinfotext += DungeonSeed.convertToCode(Dungeon.seed);
+
+			out.printf("Items for seed %s (%d):\n\n", seedinfotext, Dungeon.seed);
+		}
+
+		if (!Options.ignoreBlacklist) {
+			blacklist = Arrays.asList(Gold.class, Dewdrop.class, IronKey.class, GoldenKey.class, CrystalKey.class,
+					EnergyCrystal.class,
+					CorpseDust.class, Embers.class, CeremonialCandle.class, Pickaxe.class, Guidebook.class);
+		} else {
+			blacklist = Arrays.asList();
+		}
+
+		for (int i = 0; i < floors; i++) {
+
+			Level l = Dungeon.newLevel();
+			ArrayList<Heap> heaps = new ArrayList<>(l.heaps.valueList());
+			StringBuilder builder = new StringBuilder();
+			ArrayList<HeapItem> scrolls = new ArrayList<>();
+			ArrayList<HeapItem> potions = new ArrayList<>();
+			ArrayList<HeapItem> equipment = new ArrayList<>();
+			ArrayList<HeapItem> rings = new ArrayList<>();
+			ArrayList<HeapItem> artifacts = new ArrayList<>();
+			ArrayList<HeapItem> wands = new ArrayList<>();
+			ArrayList<HeapItem> others = new ArrayList<>();
+
+			out.printf("--- floor %d: ", Dungeon.depth);
+
+			String feeling = l.feeling.toString();
+
+			switch (feeling) {
+				case "NONE":
+					feeling = "no feeling";
+					break;
+				case "CHASM":
+					feeling = "chasms";
+					break;
+				case "WATER":
+					feeling = "water";
+					break;
+				case "GRASS":
+					feeling = "vegetation";
+					break;
+				case "DARK":
+					feeling = "enemies moving in the darkness";
+					break;
+				case "LARGE":
+					feeling = "unusually large";
+					break;
+				case "TRAPS":
+					feeling = "traps";
+					break;
+				case "SECRETS":
+					feeling = "secrets";
+					break;
+			}
+
+			switch (Dungeon.depth) {
+				case 5:
+					feeling = "goo";
+					break;
+
+				case 10:
+					feeling = "tengu";
+					break;
+
+				case 15:
+					feeling = "DM-300";
+					break;
+
+				case 20:
+					feeling = "dwarven king";
+					break;
+
+				case 25:
+					feeling = "yog dzewa";
+					break;
+			}
+
+			out.printf(feeling + "\n\n");
+
+			// list all rooms of level
+			if (Dungeon.depth % 5 != 0 && Dungeon.depth < 26 && Options.useRooms) {
+				ArrayList<String> rooms = getRooms();
+				out.printf("Rooms: \n");
+
+				for (int k = 0; k < rooms.size(); k++) {
+					out.printf("- " + rooms.get(k) + "\n");
+				}
+
+				out.printf("\n");
+			}
+
+			// list quest rewards
+			if (Ghost.Quest.armor != null) {
+				ArrayList<Item> rewards = new ArrayList<>();
+				rewards.add(Ghost.Quest.armor.inscribe(Ghost.Quest.glyph).identify());
+				rewards.add(Ghost.Quest.weapon.enchant(Ghost.Quest.enchant).identify());
+				Ghost.Quest.complete();
+
+				addTextQuest("Ghost quest rewards", rewards, builder);
+			}
+
+			if (Wandmaker.Quest.wand1 != null) {
+				ArrayList<Item> rewards = new ArrayList<>();
+				rewards.add(Wandmaker.Quest.wand1.identify());
+				rewards.add(Wandmaker.Quest.wand2.identify());
+				Wandmaker.Quest.complete();
+
+				builder.append("Wandmaker quest item: ");
+
+				switch (Wandmaker.Quest.type) {
+					case 1:
+					default:
+						builder.append("corpse dust\n\n");
+						break;
+					case 2:
+						builder.append("fresh embers\n\n");
+						break;
+					case 3:
+						builder.append("rotberry seed\n\n");
+				}
+
+				addTextQuest("Wandmaker quest rewards", rewards, builder);
+			}
+
+			if (Imp.Quest.reward != null) {
+				ArrayList<Item> rewards = new ArrayList<>();
+				rewards.add(Imp.Quest.reward.identify());
+				Imp.Quest.complete();
+
+				addTextQuest("Imp quest reward", rewards, builder);
+			}
+
+			heaps.addAll(getMobDrops(l));
+
+			// list items
+			for (Heap h : heaps) {
+				for (Item item : h.items) {
+					item.identify();
+
+					if (h.type == Type.FOR_SALE)
+						continue;
+					else if (blacklist.contains(item.getClass()))
+						continue;
+					else if (item instanceof Scroll)
+						scrolls.add(new HeapItem(item, h));
+					else if (item instanceof Potion)
+						potions.add(new HeapItem(item, h));
+					else if (item instanceof MeleeWeapon || item instanceof Armor)
+						equipment.add(new HeapItem(item, h));
+					else if (item instanceof Ring)
+						rings.add(new HeapItem(item, h));
+					else if (item instanceof Wand)
+						wands.add(new HeapItem(item, h));
+					else if (item instanceof Artifact) {
+						artifacts.add(new HeapItem(item, h));
+					} else
+						others.add(new HeapItem(item, h));
+				}
+			}
+
+			if (Options.logEquipment) {
+				addTextItems("Equipment", equipment, builder, "");
+
+				// sacrificial fire
+				if (l.sacrificialFireItem != null) {
+					if (equipment.size() == 0) {
+						builder.append("Equipment:\n");
+					}
+					Item fireItem = l.sacrificialFireItem.identify();
+
+					String tabstring = "";
+					for (int j = 0; j < Math.max(1,
+							Options.infoSpacing - fireItem.title().toLowerCase().length()); j++) {
+						tabstring += Options.spacingChar;
+					}
+
+					builder.append("- " + fireItem.title().toLowerCase() + tabstring + "(sacrificial fire)");
+					builder.append("\n\n");
+				} else {
+					builder.append("\n");
+				}
+			}
+
+			if (Options.logScrolls)
+				addTextItems("Scrolls", scrolls, builder, "\n");
+			if (Options.logPotions)
+				addTextItems("Potions", potions, builder, "\n");
+			if (Options.logRings)
+				addTextItems("Rings", rings, builder, "\n");
+			if (Options.logWands)
+				addTextItems("Wands", wands, builder, "\n");
+			if (Options.logArtifacts)
+				addTextItems("Artifacts", artifacts, builder, "\n");
+			if (Options.logOther)
+				addTextItems("Other", others, builder, "\n");
+
+			out.print(builder.toString());
+
+			Dungeon.depth++;
+		}
+
+		out.close();
+	}
+}
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java
index 8cd634460..a52f3d791 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java
@@ -79,17 +79,8 @@ public class ShatteredPixelDungeon extends Game {
 	@Override
 	public void create() {
 		super.create();
+		finish();
 
-		updateSystemUI();
-		SPDAction.loadBindings();
-		
-		Music.INSTANCE.enable( SPDSettings.music() );
-		Music.INSTANCE.volume( SPDSettings.musicVol()*SPDSettings.musicVol()/100f );
-		Sample.INSTANCE.enable( SPDSettings.soundFx() );
-		Sample.INSTANCE.volume( SPDSettings.SFXVol()*SPDSettings.SFXVol()/100f );
-
-		Sample.INSTANCE.load( Assets.Sounds.all );
-		
 	}
 
 	@Override
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/ArmoredStatue.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/ArmoredStatue.java
index 1cb53948b..7e3ac3d77 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/ArmoredStatue.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/ArmoredStatue.java
@@ -41,7 +41,7 @@ public class ArmoredStatue extends Statue {
 		spriteClass = StatueSprite.class;
 	}
 
-	protected Armor armor;
+	public Armor armor;
 
 	public ArmoredStatue(){
 		super();
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/Statue.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/Statue.java
index c0ab7e3fe..0252df7b4 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/Statue.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/Statue.java
@@ -47,7 +47,7 @@ public class Statue extends Mob {
 		properties.add(Property.INORGANIC);
 	}
 	
-	protected Weapon weapon;
+	public Weapon weapon;
 
 	public boolean levelGenStatue = true;
 	
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/npcs/Wandmaker.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/npcs/Wandmaker.java
index 9afc68954..2a27dcd7b 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/npcs/Wandmaker.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/mobs/npcs/Wandmaker.java
@@ -211,7 +211,7 @@ public class Wandmaker extends NPC {
 	
 	public static class Quest {
 
-		private static int type;
+		public static int type;
 		// 1 = corpse dust quest
 		// 2 = elemental embers quest
 		// 3 = rotberry quest
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/Heap.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/Heap.java
index 83bec2a8d..265aeeb8b 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/Heap.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/Heap.java
@@ -68,7 +68,11 @@ public class Heap implements Bundlable {
 		CRYSTAL_CHEST,
 		TOMB,
 		SKELETON,
-		REMAINS
+		REMAINS,
+		MIMIC,
+		GOLDEN_MIMIC,
+		CRYSTAL_MIMIC,
+		STATUE
 	}
 	public Type type = Type.HEAP;
 	
@@ -382,6 +386,14 @@ public class Heap implements Bundlable {
 				return Messages.get(this, "skeleton");
 			case REMAINS:
 				return Messages.get(this, "remains");
+			case MIMIC:
+				return "mimic";
+			case GOLDEN_MIMIC:
+				return "golden mimic";
+			case CRYSTAL_MIMIC:
+				return "crystal mimic";
+			case STATUE:
+				return "statue";
 			default:
 				return peek().title();
 		}
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/Item.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/Item.java
index 992bc07d1..f6512ebd9 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/Item.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/Item.java
@@ -475,6 +475,10 @@ public class Item implements Bundlable {
 	public String name() {
 		return trueName();
 	}
+
+	public String anonymousName() {
+		return "ITEM_NAME_ANONYMOUS";
+	}
 	
 	public final String trueName() {
 		return Messages.get(this, "name");
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/potions/Potion.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/potions/Potion.java
index 54d4d7b63..6f73afb38 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/potions/Potion.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/potions/Potion.java
@@ -358,6 +358,11 @@ public class Potion extends Item {
 	public String name() {
 		return isKnown() ? super.name() : Messages.get(this, color);
 	}
+
+	@Override
+	public String anonymousName() {
+		return Messages.get(this, color);
+	}
 	
 	@Override
 	public String info() {
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/rings/Ring.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/rings/Ring.java
index dcfd93106..988f4cef5 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/rings/Ring.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/rings/Ring.java
@@ -160,6 +160,11 @@ public class Ring extends KindofMisc {
 	public String name() {
 		return isKnown() ? super.name() : Messages.get(Ring.class, gem);
 	}
+
+	@Override
+	public String anonymousName() {
+		return Messages.get(Ring.class, gem);
+	}
 	
 	@Override
 	public String info(){
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/scrolls/Scroll.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/scrolls/Scroll.java
index 0c5c17105..f8c7e32ac 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/scrolls/Scroll.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/items/scrolls/Scroll.java
@@ -223,6 +223,11 @@ public abstract class Scroll extends Item {
 	public String name() {
 		return isKnown() ? super.name() : Messages.get(this, rune);
 	}
+
+	@Override
+	public String anonymousName() {
+		return Messages.get(this, rune);
+	}
 	
 	@Override
 	public String info() {
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/Level.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/Level.java
index 2410b7d19..c3a65739a 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/Level.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/Level.java
@@ -188,6 +188,8 @@ public abstract class Level implements Bundlable {
 	private static final String BLOBS		= "blobs";
 	private static final String FEELING		= "feeling";
 
+	public Item sacrificialFireItem = null;
+
 	public void create() {
 
 		Random.pushGenerator( Dungeon.seedCurDepth() );
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/RegularLevel.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/RegularLevel.java
index eed6b9282..8c8b73ab0 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/RegularLevel.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/RegularLevel.java
@@ -89,6 +89,8 @@ public abstract class RegularLevel extends Level {
 	
 	protected Room roomEntrance;
 	protected Room roomExit;
+
+	public static ArrayList<Room> roomList;
 	
 	@Override
 	protected boolean build() {
@@ -96,6 +98,7 @@ public abstract class RegularLevel extends Level {
 		builder = builder();
 		
 		ArrayList<Room> initRooms = initRooms();
+		roomList = initRooms;
 		Random.shuffle(initRooms);
 		
 		do {
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/rooms/special/SacrificeRoom.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/rooms/special/SacrificeRoom.java
index ae6f543b7..c63004448 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/rooms/special/SacrificeRoom.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/rooms/special/SacrificeRoom.java
@@ -99,6 +99,7 @@ public class SacrificeRoom extends SpecialRoom {
 			}
 		}
 		prize.cursed = prize.cursedKnown = true;
+		level.sacrificialFireItem = prize;
 
 		return prize;
 	}
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/rooms/standard/EntranceRoom.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/rooms/standard/EntranceRoom.java
index 1dddebf1b..20d18d97e 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/rooms/standard/EntranceRoom.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/rooms/standard/EntranceRoom.java
@@ -80,38 +80,6 @@ public class EntranceRoom extends StandardRoom {
 		} else {
 			level.transitions.add(new LevelTransition(level, entrance, LevelTransition.Type.REGULAR_ENTRANCE));
 		}
-
-		//use a separate generator here so meta progression doesn't affect levelgen
-		Random.pushGenerator();
-
-		//places the first guidebook page on floor 1
-		if (Dungeon.depth == 1 &&
-				(!Document.ADVENTURERS_GUIDE.isPageRead(Document.GUIDE_INTRO) || SPDSettings.intro() )){
-			int pos;
-			do {
-				//can't be on bottom row of tiles
-				pos = level.pointToCell(new Point( Random.IntRange( left + 1, right - 1 ),
-						Random.IntRange( top + 1, bottom - 2 )));
-			} while (pos == level.entrance() || level.findMob(level.entrance()) != null);
-			level.drop( new Guidebook(), pos );
-			Document.ADVENTURERS_GUIDE.deletePage(Document.GUIDE_INTRO);
-		}
-
-		//places the third guidebook page on floor 2
-		if (Dungeon.depth == 2 && !Document.ADVENTURERS_GUIDE.isPageFound(Document.GUIDE_SEARCHING)){
-			int pos;
-			do {
-				//can't be on bottom row of tiles
-				pos = level.pointToCell(new Point( Random.IntRange( left + 1, right - 1 ),
-						Random.IntRange( top + 1, bottom - 2 )));
-			} while (pos == level.entrance() || level.findMob(level.entrance()) != null);
-			GuidePage p = new GuidePage();
-			p.page(Document.GUIDE_SEARCHING);
-			level.drop( p, pos );
-		}
-
-		Random.popGenerator();
-
 	}
 
 	@Override
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/messages/Languages.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/messages/Languages.java
index f357bf359..5dfddb9fc 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/messages/Languages.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/messages/Languages.java
@@ -98,10 +98,6 @@ public enum Languages {
 	}
 
 	public static Languages matchCode(String code){
-		for (Languages lang : Languages.values()){
-			if (lang.code().equals(code))
-				return lang;
-		}
 		return ENGLISH;
 	}
 
diff --git a/desktop/src/main/java/com/shatteredpixel/shatteredpixeldungeon/desktop/DesktopLauncher.java b/desktop/src/main/java/com/shatteredpixel/shatteredpixeldungeon/desktop/DesktopLauncher.java
index 351384c1b..85febe7e2 100644
--- a/desktop/src/main/java/com/shatteredpixel/shatteredpixeldungeon/desktop/DesktopLauncher.java
+++ b/desktop/src/main/java/com/shatteredpixel/shatteredpixeldungeon/desktop/DesktopLauncher.java
@@ -28,6 +28,7 @@ import com.badlogic.gdx.backends.lwjgl3.Lwjgl3FileHandle;
 import com.badlogic.gdx.backends.lwjgl3.Lwjgl3Preferences;
 import com.badlogic.gdx.utils.SharedLibraryLoader;
 import com.shatteredpixel.shatteredpixeldungeon.SPDSettings;
+import com.shatteredpixel.shatteredpixeldungeon.SeedFinder;
 import com.shatteredpixel.shatteredpixeldungeon.ShatteredPixelDungeon;
 import com.shatteredpixel.shatteredpixeldungeon.services.news.News;
 import com.shatteredpixel.shatteredpixeldungeon.services.news.NewsImpl;
@@ -185,6 +186,9 @@ public class DesktopLauncher {
 		config.setWindowIcon("icons/icon_16.png", "icons/icon_32.png", "icons/icon_48.png",
 				"icons/icon_64.png", "icons/icon_128.png", "icons/icon_256.png");
 
+		config.setInitialVisible(false);
 		new Lwjgl3Application(new ShatteredPixelDungeon(new DesktopPlatformSupport()), config);
+
+		new SeedFinder(args);
 	}
 }
-- 
2.43.0.windows.1

